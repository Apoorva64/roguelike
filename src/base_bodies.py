from loading import load, TILE_SIZE
import pygame
import math
from enum import Enum
import random
from typing import Tuple, List, Any
# from game_class import Game
# from maps.map_generation import MAP_SIZE
import pygame_gui
import hud
from enums import *
from load_settings import settings

#
MAP_SIZE = settings['map_generation']['MAP_SIZE']
textures = load()
# init fonts
pygame.font.init()
font = pygame.font.SysFont('', 24)
# base stats
DASH_ACCELERATION = settings["base_character_stats"]["DASH_ACCELERATION"]
WALKING_ACCELERATION = settings["base_character_stats"]["WALKING_ACCELERATION"]
MAX_STAMINA = settings["base_character_stats"]["MAX_STAMINA"]
STAMINA_GAIN = settings["base_character_stats"]["STAMINA_GAIN"]
STAMINA_DASH_DRAIN = settings["base_character_stats"]["STAMINA_DASH_DRAIN"]
START_HP = settings["base_character_stats"]["START_HP"]
HEALTH_REGEN = settings["base_character_stats"]["HEALTH_REGEN"]
MAX_MAGIC = settings["base_character_stats"]["MAX_MAGIC"]
MAGIC_REGEN = settings["base_character_stats"]["MAGIC_REGEN"]
WALL_BOUNCINESS = settings["base_character_stats"]["WALL_BOUNCINESS"]
BULLET_FIRE_RATE = settings["base_character_stats"]["BULLET_FIRE_RATE"]  # delay in milliseconds between shots
GAME_SIZE = settings["base_character_stats"]["GAME_SIZE"]
MAX_BULLETS = settings["base_character_stats"]["MAX_BULLETS"]
MAX_HP = settings["base_character_stats"]["MAX_HP"]
BULLET_POWER = settings["base_character_stats"]["BULLET_POWER"]
BULLET_MAX_SPEED = settings["base_character_stats"]["BULLET_MAX_SPEED"]
BULLET_ACCELERATION = settings["base_character_stats"]["BULLET_ACCELERATION"]
BASE_DISPLAY_SIZE = settings["game_class"]["BASE_DISPLAY_SIZE"]


def blit_rotate(surf, image, center, angle):
    """
    rotates a surface and bilts it
    :param surf: surface to blit on
    :param image: image to bit on surf
    :param center: center of rotation
    :param angle: angle to rotate in degrees
    :return: new_rect: the new rectangle generated by rotating the rect
    """
    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center=image.get_rect(center=center).center)
    surf.blit(rotated_image, new_rect.topleft)
    # pygame.draw.rect(surf, (255, 0, 0), new_rect, 2)
    # pygame.draw.circle(surf, (255, 255, 0), new_rect.center, 20)
    return new_rect


def find_collisions(_object, object_to_collide_with_list):
    """
    finds collision between _object and object_to_collide_with_list
    :param _object: Element object with a rect
    :param object_to_collide_with_list: list of elements objects with a rect
    :returns: a list of the objects _object collided with
    """
    # collided_with = []
    # for obj in object_to_collide_with_list:
    #     if obj != _object and obj.rect.colliderect(_object.rect):
    #         # collided_with.append(obj)
    #         yield obj
    return [obj for obj in object_to_collide_with_list if (obj != _object and obj.rect.colliderect(_object.rect))]

    # return collided_with


# check if object is in map
def is_in_map(x, y):
    return 0 <= x <= (MAP_SIZE - 1) * TILE_SIZE and 0 <= y <= (MAP_SIZE - 1) * TILE_SIZE


class Particle:

    def __init__(self, parent_obj: Any, pos: Tuple[int, int], color: Tuple[int, int, int], randomness: int = 2,
                 rad: int = 5) -> None:
        """
        Particle base class
        :param parent_obj: parent object of the class
        :param pos: initial position of the particle
        :param color: color of the particle
        :param randomness: random forces to be applied to the particle
        :param rad: particle radius
        """
        self.parent_obj = parent_obj
        self.x, self.y = pos[0], pos[1]
        self.vx, self.vy = random.randint(-randomness, randomness), random.randint(-randomness * 10,
                                                                                   randomness * 10) * .1
        self.color = color
        self.rad = rad
        self.randomness = randomness

    def draw(self, win, scroll, lod):
        """
        Draws the particle
        :param win: surface to draw on
        :param scroll: game scroll
        :param lod: game lod
        """
        pygame.draw.circle(win, self.color, ((self.x - scroll[0]) / lod, (self.y - scroll[1]) / lod),
                           self.rad / (100 * lod / TILE_SIZE))

    def update(self, dt, var2=None):
        """Updates the position of the particle"""
        self.x += self.vx * dt / (100 / TILE_SIZE)
        self.y += self.vy * dt / (100 / TILE_SIZE)
        if random.randint(0, self.randomness * 50) < 40:
            self.rad -= 1
        if self.rad < 0 and self.parent_obj:
            self.parent_obj.particles.remove(self)
            del self


class ParticleSystem:
    def __init__(self, pos, color=(255, 255, 255)):
        self.pos = pos
        self.particles = []
        self.color = color

    def add_particles(self, amount, x, y, randomness=2):
        for i in range(amount):
            self.particles.append(Particle(self, (x, y), self.color, randomness=randomness))

    def update(self, dt):
        [i.update(dt) for i in self.particles]

    def draw(self, win, scroll, lod):
        [i.draw(win, scroll, lod) for i in self.particles]


class Element(Particle):
    dt = 1

    def __init__(self, name, parent_obj=None, pos=(0, 0), color=(255, 255, 255), abbreviation=None, image=None):
        super().__init__(parent_obj, pos, color, randomness=100)
        self.name = name
        if image:
            self.image = pygame.transform.scale(image, (TILE_SIZE, TILE_SIZE))
        else:
            self.image = pygame.Surface((TILE_SIZE, TILE_SIZE))
            self.image.fill((0, 0, 0))
            self.image.blit(font.render(self.name, True, color), (TILE_SIZE // 2, TILE_SIZE // 2))

        self.rect = pygame.Rect((0, 0), (TILE_SIZE, TILE_SIZE))
        if abbreviation:
            self.abbreviation = abbreviation
        else:
            self.abbreviation = name[0]
        self.particle_system = ParticleSystem((0, 0))

    def __repr__(self):
        return self.abbreviation

    def description(self):
        return f"<{self.name}>"

    def update(self, player, var2=None):
        vector_between_player_and_object = pygame.math.Vector2(player.x - self.x, player.y - self.y)

        self.vx, self.vy = self.vx / 1.2, self.vy / 1.2
        self.x += self.vx * self.dt / (100 / TILE_SIZE)
        self.y += self.vy * self.dt / (100 / TILE_SIZE)

        self.rect.x, self.rect.y = self.x, self.y
        if vector_between_player_and_object.magnitude() < 1000:
            self.particle_system.add_particles(random.getrandbits(1), self.x, self.y, 2)

            self.vx, self.vy = self.vx + vector_between_player_and_object[0] / 100, self.vy + \
                               vector_between_player_and_object[1] / 100
        self.particle_system.update(self.dt)

        if self.rect.colliderect(player.rect) and not player.inventory.is_inventory_full():
            player.inventory.add_element(self)
            player.game.data['sounds']['pickup.wav'].set_volume(200)
            player.game.collect_sound_mixer.play(player.game.data['sounds']['pickup.wav'])
            return True
        else:
            return False

    def draw(self, win, scroll, lod):

        win.blit(pygame.transform.scale(self.image, (TILE_SIZE // lod, TILE_SIZE // lod)),
                 ((self.x - scroll[0]) / lod, (self.y - scroll[1]) / lod))
        self.particle_system.draw(win, scroll, lod)


class Usable(Element):
    def use(self, player):
        raise NotImplementedError


class StaticObject:
    def __init__(self, x, y, x_size, y_size, object_type=ObjectType.GROUND):
        self.width = x_size
        self.height = y_size
        self.object_type = object_type
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.x = x
        self.y = y
        if self.object_type == ObjectType.CHEST:
            self.texture = None
        else:
            if self.object_type != ObjectType.EMPTY:
                self.texture = textures["enviroment_textures"][str(self.object_type.value)][0]
            else:
                self.texture = textures["enviroment_textures"]['background'][0]

    def __repr__(self):
        return str(self.object_type.value)

    # def draw(self, screen, scroll, lod):
    #     if 0 <= int(self.x - scroll[0]) <= GAME_SIZE[0] and 0 <= int(self.y - scroll[1]) <= GAME_SIZE[1]:
    #         screen.blit(self.texture, (self.rect.x - scroll[0], self.rect.y - scroll[1]))


class PhysicalObject(Element):
    def __init__(self, x: int, y: int, x_size: int, y_size: int, game, object_type: ObjectType,
                 name: str) -> None:
        """
        Objects that is tied with physics
        :param x: position x
        :param y: position y
        :param x_size: x_size
        :param y_size: y_size
        :param object_type: object type can be found in ObjectType Enum
        """
        super().__init__(name)
        self.width = x_size
        self.height = y_size
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.x = x
        self.y = y
        self.acceleration = pygame.math.Vector2(0, 0)
        self.speed = pygame.math.Vector2(0, 0)
        self.player_movement = [0, 0]
        self.dt = 1
        self.object_type = object_type
        self.game = game

    def update_speed(self):
        """
        Updates the speed of the object each frame
        """
        if self.speed.length() < 0.2:
            self.speed = pygame.math.Vector2(0, 0)
        self.speed = self.speed + self.acceleration

    def apply_acceleration(self, movement):
        """
        changes the acceleration of the object
        :param movement: target acceleration
        """
        self.acceleration = movement

    def update_position(self, platforms: List):
        """
        Updates the position of the player accounting the collisions
        :param platforms: Physical object to account collisions with
        :return collision_data: A dict with the collisions with all the objects
        """
        if not isinstance(platforms, list):
            platforms = [platforms]
        movement = self.speed
        collision_data = {'top': False,
                          'bottom': False,
                          'right': False,
                          'left': False,
                          'slant_bottom': False,
                          'data': {}}
        # checking on x axis
        self.x += movement[0] * self.dt / (100 / TILE_SIZE)
        if not is_in_map(self.x, self.y):
            self.x -= movement[0] * self.dt / (100 / TILE_SIZE)
            self.acceleration[0] *= -1
            collision_data['right'] = collision_data['left'] = collision_data['top'] = collision_data[
                'bottom'] = True
        self.rect.x = int(self.x)
        block_hit_list = find_collisions(self, platforms)
        y = int(self.rect.centery // TILE_SIZE)
        x = int(self.rect.centerx // TILE_SIZE)
        try:
            if self.game.game_map.numpy_map[int(self.rect.centery // TILE_SIZE)][
                int(self.rect.centerx // TILE_SIZE)] == 0:
                border_object = self.game.game_map.get_map()['full_map'][y][x]
                if isinstance(border_object, StaticObject) and border_object.object_type == ObjectType.BORDER:
                    block_hit_list.append(border_object)
                else:
                    collision_data['right'] = collision_data['left'] = collision_data['top'] = collision_data[
                        'bottom'] = True
                # block_hit_list.append(self.game.game_map._mat['full_map'][y][x])
        except IndexError:
            print('bullet has fcked up')
        for _object in block_hit_list:
            markers = {'left': False,
                       'right': False,
                       'top': False,
                       'bottom': False}
            if movement[0] > 0:
                self.rect.right = _object.rect.left
                collision_data['right'] = True
                markers['left'] = True
            elif movement[0] < 0:
                self.rect.left = _object.rect.right
                collision_data['left'] = True
                markers['right'] = True
            collision_data['data'][_object] = markers
            self.x = self.rect.x

        # checking on y axis
        self.y += movement[1] * self.dt / (100 / TILE_SIZE)
        if not is_in_map(self.x, self.y):
            self.y -= movement[1] * self.dt / (100 / TILE_SIZE)
            self.acceleration[1] *= -1
            collision_data['right'] = collision_data['left'] = collision_data['top'] = collision_data[
                'bottom'] = True
        self.rect.y = int(self.y)
        block_hit_list = find_collisions(self, platforms)
        y = int(self.rect.centery // TILE_SIZE)
        x = int(self.rect.centerx // TILE_SIZE)
        try:
            if self.game.game_map.numpy_map[int(self.rect.centery // TILE_SIZE)][
                int(self.rect.centerx // TILE_SIZE)] == 0:
                border_object = self.game.game_map.get_map()['full_map'][y][x]
                if isinstance(border_object, StaticObject) and border_object.object_type == ObjectType.BORDER:
                    block_hit_list.append(border_object)
                else:
                    collision_data['right'] = collision_data['left'] = collision_data['top'] = collision_data[
                        'bottom'] = True
                # block_hit_list.append(self.game.game_map._mat['full_map'][y][x])
        except IndexError:
            print('bullet has fcked up')

        for _object in block_hit_list:
            try:
                collision_data['data'][_object]['top'] = False
            except KeyError:
                collision_data['data'][_object] = {'left': False,
                                                   'right': False,
                                                   'top': False,
                                                   'bottom': False}

            if movement[1] > 0:
                self.rect.bottom = _object.rect.top
                collision_data['bottom'] = True
                collision_data['data'][_object]['top'] = True
            elif movement[1] < 0:
                self.rect.top = _object.rect.bottom
                collision_data['top'] = True
                collision_data['data'][_object]['bottom'] = True
            # collision_data['data'].append([_object, markers])
            self.y = self.rect.y

        return collision_data


class Creature(PhysicalObject):
    dt = 1

    def __init__(self,
                 name,
                 x: int,
                 y: int,
                 x_size: int,
                 y_size: int,
                 game,
                 object_type: ObjectType,
                 screen_manager: pygame_gui.UIManager,
                 start_hp: float = START_HP,
                 dash_acceleration: float = DASH_ACCELERATION,
                 walking_acceleration: float = WALKING_ACCELERATION,
                 max_stamina: float = MAX_STAMINA,
                 stamina_gain: float = STAMINA_GAIN,
                 stamina_dash_drain: float = STAMINA_DASH_DRAIN,
                 max_hp: float = MAX_HP,
                 health_regen: float = HEALTH_REGEN,
                 max_magic: float = MAX_MAGIC,
                 magic_regen: float = MAGIC_REGEN,
                 level=1,

                 ) -> None:
        """
        :param x: x position of the Creature
        :param y: y position of the Creature
        :param x_size: x_size of the Creature
        :param y_size: y size of the Creature
        :param start_hp: Creature start Hp
        :param dash_acceleration: Creature's dash acceleration
        :param walking_acceleration: Creature's walking acceleration
        :param max_stamina: Creature's maximum stamina
        :param stamina_gain: Creature's stamina gain
        :param stamina_dash_drain: Creature's dash stamina drain
        :param max_hp: Creature's Max hp
        """
        self.base_name = name
        name = f"""name: {name}
        level: {level}
        x_size: {x_size}
        y_size: {y_size}
        start_hp:{start_hp}
        dash_acceleration: {dash_acceleration}
        walking acceleration: {walking_acceleration}
        max_hp: {max_hp}
        health_regen: {health_regen}"""
        super().__init__(x, y, x_size, y_size, game, object_type, name)

        self.inventory = None
        self.stamina_capacity = max_stamina
        self.level = level
        # self.creature_list = creature_list
        self.current_stamina = 0
        self.current_health = start_hp * level
        self.health_capacity = max_hp * level
        self.dash_acceleration = dash_acceleration * level
        self.walking_acceleration = walking_acceleration * level
        self.stamina_gain = stamina_gain * level
        self.stamina_dash_drain = stamina_dash_drain * level
        self.health_regen = health_regen * level
        self.magic_capacity = max_magic * level
        self.magic_regen = magic_regen * level
        self.current_magic = 0
        self.is_alive = True
        self.main_display_rect = pygame.Rect((0, 0), (x_size, y_size))
        self.screen_manager = screen_manager
        self.hp_bar = hud.CustomUiHealthBar(
            pygame.Rect((0, 0), (
                150 * self.game.base_display.get_size()[0] / 1080, 30 * self.game.base_display.get_size()[0] / 1080)),
            self.game.manager, self)
        self.hp_bar.bar_filled_colour = pygame_gui.core.ColourGradient(0, pygame.Color(0, 0, 0),
                                                                       pygame.Color(120, 200, 120))
        self.hp_bar.bar_unfilled_colour = pygame_gui.core.ColourGradient(0, pygame.Color(255, 0, 0),
                                                                         pygame.Color(0, 20, 10))
        self.hp_bar.rebuild()
        self.game = game
        self.hp_bar.hide()

    def update_health_bar(self):
        self.hp_bar.rect.midbottom = self.main_display_rect.midtop

    def update(self, arg1, arg2=None):
        self.name = f"""name: {self.base_name}
        level: {self.level}
        x_size: {self.width}
        y_size: {self.height}
        start_hp:{self.current_health}
        dash_acceleration: {self.dash_acceleration}
        walking acceleration: {self.walking_acceleration}
        max_hp: {self.health_capacity}
        health_regen: {self.health_regen}
        magic: {self.current_magic}
        magic_regen: {self.magic_regen}
        magic_capacity: {self.magic_capacity}
        
        """
        if self.current_health < self.health_capacity:
            self.current_health += self.health_regen * self.dt
        else:
            self.current_health = self.health_capacity
        # update stamina
        if self.current_stamina < self.stamina_capacity:
            self.current_stamina += self.stamina_gain * self.dt
        else:
            self.current_stamina = self.stamina_capacity

        # update magic
        if self.current_magic < self.magic_capacity:
            self.current_magic += self.magic_regen * self.dt
        else:
            self.current_magic = self.magic_capacity
        # self.current_health = int(self.current_health)
        # self.stamina = round(self.current_health, 4)

    def apply_damage(self, power, vector):
        self.current_health -= power
        try:
            self.speed += vector.normalize() * power
        except ValueError:
            print('cannceling recoil cannont calculate vector')
        if self.current_health < 0:
            self.is_alive = False
            self.current_health = 0

    def draw(self, win, scroll, lod):
        self.main_display_rect = pygame.Rect(0,
                                             0,
                                             self.rect.width,
                                             self.rect.height)
        self.main_display_rect = self.game.scale_rect_to_base_display(self.main_display_rect)

        self.main_display_rect.center = self.game.scale_to_base_display(self.rect.center)

        # self.main_display_rect.centerx = (self.rect.centerx - scroll[0]) / lod
        # self.main_display_rect.centery = (self.rect.centery - scroll[1]) / lod
        self.update_health_bar()
        if self.game.night_mode:
            light = self.game.light[self.game.lod]
            # light_size = light.get_size()
            # light=pygame.transform.scale(light,(light_size[0]//2,light_size[0]//2))
            light_rect = light.get_rect()
            center = self.game.scale_to_screen(self.rect.center)
            light_rect.center = (center[0] // self.game.fog_resolution, center[1] // self.game.fog_resolution)
            self.game.fog.blit(light, light_rect)

    def description(self):
        return Element.description(self) + f"({self.current_health})"
